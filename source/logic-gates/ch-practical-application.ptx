<section xml:id="sec-practical-applications">
    <title>Practical Applications of Logic Gates</title>

    <p>
        Logic gates are everywhere in the devices we use daily, from smartphones to computers. They form the foundation of how digital systems process data, perform calculations, and store information. Let's explore a few key applications of logic gates that students can relate to and encounter in real-world scenarios.
    </p>

    <subsection xml:id="sec-full-adder">
        <title>Full Adder: Arithmetic with Logic Gates</title>
        <p>
            One of the most important uses of logic gates is in performing arithmetic operations, specifically addition. A full adder is a logic circuit that adds three bitsâ€”two input bits and a carry bit from the previous stage. It produces a sum and a carry-out value. Full adders are a crucial component in building arithmetic logic units (ALUs) within processors, where they handle addition and subtraction operations.
        </p>
        <p>
            The full adder is built using a combination of XOR, AND, and OR gates. The XOR gate is used to calculate the sum, while the AND and OR gates are used to handle the carry bits.
        </p>
        <sage>
            <input>
                from sympy.logic.boolalg import Xor, And, Or
                from sympy.abc import A, B, C

                # Full Adder logic
                def full_adder(A, B, C):
                    sum_output = Xor(Xor(A, B), C)
                    carry_output = Or(And(A, B), And(Xor(A, B), C))
                    return sum_output, carry_output

                # Print full truth table for Full Adder
                print("A B C | Sum Carry")
                print("-" * 20)
                for A_val in [False, True]:
                    for B_val in [False, True]:
                        for C_val in [False, True]:
                            sum_output, carry_output = full_adder(A_val, B_val, C_val)
                            # Convert SymPy booleans to Python booleans and then to integers
                            print(f"{int(bool(A_val))} {int(bool(B_val))} {int(bool(C_val))} | {int(bool(sum_output))}   {int(bool(carry_output))}")
            </input>
            <output>
                # Displays the full truth table for the Full Adder
            </output>
        </sage>
        <p>
            The full adder circuit forms the basis for more complex operations like multiplication and division in processors, making it one of the most fundamental building blocks of digital arithmetic.
        </p>
    </subsection>

    <subsection xml:id="sec-multiplexer">
        <title>Multiplexers: Routing Data</title>
        <p>
            Multiplexers, often called "muxes," are circuits that use logic gates to select one of several inputs and route it to a single output line. A multiplexer allows multiple signals to share a single device or resource, such as a communication line, reducing the need for multiple data paths. Multiplexers are crucial in data routing, especially in networks and communication systems.
        </p>
        <p>
            For example, consider a 4-to-1 multiplexer, which has four inputs but only one output. The selection of which input is passed to the output is controlled by additional logic signals, called select lines.
        </p>
        <sage>
            <input>
                from sympy.logic.boolalg import Or, And, Not
                from sympy import symbols

                # Define variables A, B, S0, S1
                A, B, S0, S1 = symbols('A B S0 S1')

                # 4-to-1 Multiplexer logic
                mux_output = Or(
                    And(Not(S0), Not(S1), A),  # Select input A
                    And(S0, Not(S1), B),       # Select input B
                    # Additional inputs can be added for larger multiplexers
                )

                # Assign input and select line values
                A_val = True
                B_val = False
                S0_val = True
                S1_val = False

                # Evaluate the multiplexer
                evaluated_mux = mux_output.subs({A: A_val, B: B_val, S0: S0_val, S1: S1_val})
                evaluated_mux
            </input>
            <output>
                # Displays the evaluated output for the multiplexer
            </output>
        </sage>

        <p>
            Multiplexers are heavily used in communication systems, like in your computer's CPU, to manage and control the flow of data between different components.
        </p>
    </subsection>

    <subsection xml:id="sec-memory-circuits">
        <title>Memory Circuits: Storing Data</title>
        <p>
            Another critical application of logic gates is in memory circuits, which are responsible for storing data in digital systems. Basic memory elements like SR flip-flops are made using combinations of NAND or NOR gates. These flip-flops act as 1-bit memory cells, where the state of the gates determines whether the circuit stores a 0 or a 1.
        </p>
        <p>
            Here's an example of a simple SR flip-flop, which uses two cross-coupled NAND gates. The SR flip-flop can "remember" its state, making it one of the fundamental circuits in building larger memory units like RAM.
        </p>
        <sage>
            <input>
from sympy.logic.boolalg import Nand
from sympy import symbols

# Define variables S, R
S, R = symbols('S R')

# SR Flip-flop using NAND gates
Q_not = Nand(R, True)  # Assume initial state for Q (True in this case)
Q = Nand(S, Q_not)     # Set input (S)

# Assign initial values for Set and Reset
S_val = True
R_val = False

# Now evaluate both Q and Q_not with the given S and R values
evaluated_Q_not = Q_not.subs({R: R_val})
evaluated_Q = Q.subs({S: S_val, Q_not: evaluated_Q_not})

evaluated_Q, evaluated_Q_not
            </input>
            <output>
                # Displays the output Q and Q_not for the SR flip-flop
            </output>
        </sage>

        <p>
            Memory circuits like this are used to build larger memory systems such as registers and Random Access Memory (RAM), where bits of data need to be stored and accessed efficiently.
        </p>
    </subsection>

    <p>
        These are just a few examples of how logic gates are used in real-world applications. From performing arithmetic operations in processors, routing data in communication systems, to storing data in memory circuits, logic gates form the backbone of modern computing systems.
    </p>
</section>