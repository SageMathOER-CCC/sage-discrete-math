<?xml version="1.0" encoding="UTF-8"?>
<section xml:id="sec-modeling-finite-state-machines" xmlns:xi="http://www.w3.org/2001/XInclude"
    xml:lang="en">
    <title>State Machine in Sage</title>
    <idx>
        <h>state machines</h>
        <h>model</h>
    </idx>
    <introduction>
        <p>
            Although Sage does have a dedicated built-in module to handle state
            machines, we can still model, construct, display, and run relatively
            simple state machines, leveraging the general-purpose tools, such as graphs and
            transition matrices, to represent and work with state machines.</p>
        <p>
            In this section, we'll explore how to define states, create a state transition graph,
            visualize the state machine, and simulate its execution in Sage.</p>

        <aside>
            <title>Notes</title>
            <p> While Sage provides basic tools to represent and simulate state machines,
                it may not natively support more complex state machine features such as parallel
                states or hierarchical transitions.</p>
        </aside>
        </introduction>

    <subsection>
        <title>Example of Application of FSMs</title>
        <p>
            Let's consider the example of an elevator for 3 floors. Being in a given floor <m>i</m> would represent
            a distinct state <m>f_i</m>, so that we can have the subset of states <m>S=\{f_1,\;f_2,\;f_3\}</m>.</p>
        <p>
            The elevator has 3 buttons as inputs for users to select the destination floor <m>X=\{1,\;2,\;3\}</m>, and
            based of which the elevator can either go up, go down, or stay in the same floor.</p>
        <p>
            Let's have the set of outputs <m>O=\{N,\;U,\;D\}</m> to represent the outputs ,"do nothing", "go up",
            "go down" respectively. The following table shows the state machine representation of this elevator.</p>
        <table>
            <title>Elevator State Machine: Transitions and Outputs</title>
            <p> Assume there is a 3-levels elevator (floors 1 thru 3). this elevator moves in the
                same direction (up or down) until it reaches the last floor while moving up, or
                the first floor while moving down. It makes stop at every floor on its way up or
                down. Each floor has 3 buttons to press while selecting the destination floor.
            </p>
            <p> Next, we'll see how to model and simulate this system using an FSM. In this example,
                we have the various states <m>S={fl_1, fl_2, fl_3}</m> representing each of the
                floors, the different user inputs <m>X={push-1, push-2, push-3}</m>, and the
                possible outputs for the elevator <m>Z={go_up, go_down, no_action}</m> The different
                components of this FSM can be transcribed in the following table. </p>
            <tabular halign="center">
                <row header="yes" bottom="major">
                    <cell></cell>

                    <cell>|</cell>

                    <cell></cell>
                    <cell>next</cell>
                    <cell></cell>

                    <cell>|</cell>

                    <cell></cell>
                    <cell>output</cell>
                    <cell></cell>
                </row>
                <row header="yes" bottom="minor">
                    <cell>current</cell>
                    <cell>|</cell>

                    <cell>(1)</cell>
                    <cell>(2)</cell>
                    <cell>(3)</cell>

                    <cell>|</cell>

                    <cell>(1)</cell>
                    <cell>(2)</cell>
                    <cell>(3)</cell>
                </row>

                <row>
                    <cell><m>f_1</m></cell>

                    <cell>|</cell>

                    <cell><m>f_1</m></cell>
                    <cell><m>f_2</m></cell>
                    <cell><m>f_3</m></cell>

                    <cell>|</cell>

                    <cell><m>N</m></cell>
                    <cell><m>U</m></cell>
                    <cell><m>U</m></cell>
                </row>

                <row>
                    <cell><m>f_2</m></cell>

                    <cell>|</cell>

                    <cell><m>f_1</m></cell>
                    <cell><m>f_2</m></cell>
                    <cell><m>f_3</m></cell>

                    <cell>|</cell>

                    <cell><m>D</m></cell>
                    <cell><m>N</m></cell>
                    <cell><m>U</m></cell>
                </row>

                <row>
                    <cell><m>f_3</m></cell>

                    <cell>|</cell>

                    <cell><m>f_1</m></cell>
                    <cell><m>f_2</m></cell>
                    <cell><m>f_3</m></cell>

                    <cell>|</cell>

                    <cell><m>D</m></cell>
                    <cell><m>D</m></cell>
                    <cell><m>N</m></cell>
                </row>

            </tabular>
        </table>
    </subsection>

    <subsection>
        <title>Define States, Transitions and Outputs</title>
        <p> The first step is to define the states and transitions in the state machine. We can
            represent these using lists and dictionaries.
        </p>
        <sage>
            <input>
                # Define state, input and output sets
                states = ['f1', 'f2', 'f3']
                inputs = ['1', '2', '3']
                outputs = ['U', 'D', 'N']

                # transitions are defined as a dictionary {(current_state, input): next_state}
                transitions = {
                    ('f1', '1'): 'f1',
                    ('f1', '2'): 'f2',
                    ('f1', '3'): 'f3',

                    ('f2', '1'): 'f1',
                    ('f2', '2'): 'f2',
                    ('f2', '3'): 'f3',

                    ('f3', '1'): 'f1',
                    ('f3', '2'): 'f2',
                    ('f3', '3'): 'f3',
                }

                # The machine output controls how the elevator would move
                outputs = {
                    ('f1', '1'): 'N',
                    ('f1', '2'): 'U',
                    ('f1', '3'): 'U',

                    ('f2', '1'): 'D',
                    ('f2', '2'): 'N',
                    ('f2', '3'): 'U',

                    ('f3', '1'): 'D',
                    ('f3', '2'): 'D',
                    ('f3', '3'): 'N',
                }

                # Display the machine configuration
                print('States: ', states)
                print('Transitions: ', transitions)
                print('Outputs: ', outputs)
            </input>
            <output></output>
        </sage>
        <p>
            The states are defined as vertices in the graph, the transitions (along with the
            outputs) are defined as directed
            edges between these vertices.</p>
    </subsection>
    <subsection>
        <title>Graph Model of a Finite State Machine</title>
        <p> In Sage, we can use the <c>DiGraph</c> class to represent the states, transitions and
            outputs of the state machine as a directed graph, and use the graph structure to
            visualize the state machine representation.</p>
        <sage>
            <input>
                # 'DiGraph' is imported by default. If not, it can be imported as follow
                # from sage.graphs.digraph import DiGraph

                # Initialize a directed graph
                SM = DiGraph(loops=True)

                # Add states as vertices
                SM.add_vertices(states)

                # Add transitions and outputs as edges
                for (_state, _input), next_state in transitions.items():
                    _output = outputs[(_state, _input)]
                    edge_label = f"{_input}, {_output}"
                    SM.add_edge(_state, next_state, label=edge_label)

                # Display the graph (state machine)
                SM.show(
                        figsize=[5.6, 5.6],
                        layout='circular',
                        vertex_size=250,
                        edge_labels=True,
                        vertex_labels=True,
                        edge_color=(.2,.4,1),
                        edge_thickness=1.0,
                )
            </input>
            <output></output>
        </sage>
        <p> The <c>SM.show()</c> command renders a graphical representation of the state machine.
            Each vertex in the graph represents a state, and each directed edge represents a
            transition, labeled as (input, output).</p>
    </subsection>

    <subsection>
        <title>Run the State Machine</title>
        <p>
            Next, we can simulate the state machine's behavior by creating a function that
            processes a list of inputs and transitions through the states accordingly.</p>
        <sage>
            <input>
                # Function to run the state machine
                def run_state_machine(start_state, inputs):
                    current_state = start_state
                    for _input in inputs:
                        print(f"Current State: {current_state}, Input: {_input}")

                        if (current_state, _input) in transitions:
                            current_output = outputs[(current_state, _input)]
                            current_state = transitions[(current_state, _input)]
                            print(
                                f"Transitioned to: {current_state}\n"
                                f"Output: {current_output}\n"
                            )
                        else:
                            print(
                                f"No transition/output available for input {_input} in state {current_state}"
                            )
                            break

                    print(f"New State: {current_state}")

                # Example of running the state machine
                start_state = 'f2'
                inputs = ['1', '1', '3', '2']

                run_state_machine(start_state, inputs)
            </input>
            <output></output>
        </sage>
        <p> The <c>run_state_machine</c> function simulates the state machine by processing a list
            of inputs starting from an initial state.</p>
    </subsection>

    <subsection>
        <title>Using Sage built-in `FiniteStateMachine'</title>
        <p>
            In this section, we'll the Sage built-in library for FSM, to model and run a very basic
            traffic light system, controlled only by a preset timer and has 3 traffic lights: (G)reen,
            (Y)ellow, and (R)ed.
        </p>
        <p>
            <c>FiniteStateMachine()</c> is used define an <em>empty</em> state machine.</p>
        <sage>
            <input>
                from sage.combinat.finite_state_machine import FSMState

                # define the states, inputs and outputs of the FSM that models a simple traffic light
                # GO for light being gree, HOLD for light being yellow, and STOP for light being red.
                states = ['GO', 'HOLD', 'STOP']

                # FSM inputs and outputs
                inputs = [30, 5, 30]        # timer duration
                outputs = ['G', 'Y', 'R']   # light turns Green, Yellow, Red

                # Create an empty state machine object
                fsm = FiniteStateMachine()
                fsm
            </input>
            <output></output>
        </sage>
        <p>
            <c>FSMState()</c> helps define state for the given label, the <c>is_initial</c> flag can
            be set to true to indicate the current state will be the <em>initial state</em> of the
            finite state machine. <c>add_state()</c> method is then used to append the state to the
            state machine</p>
        <sage>
            <input>
                go = FSMState('GO', is_initial=True)
                fsm.add_state(go)

                # Adding more states
                hold = fsm.add_state('HOLD')
                stop = fsm.add_state('STOP')

                # the FiniteStateMachine instance
                fsm
            </input>
            <output></output>
        </sage>
        <p> To check whether or not a finite state machine has a state defined, <c>has_state()</c>
            method can be used by passing in the state label (case-sensitive).</p>
        <sage>
            <input>
                fsm.has_state('GO')
            </input>
            <output></output>
        </sage>
        <p>
            <c>states()</c> method is used to enumerate the list of all defined states of the state
            machine.</p>
        <sage>
            <input>
                fsm.states()
            </input>
            <output></output>
        </sage>
        <p>
            <c>initial_states()</c> method lists the defined initial state(s) of the state machine.</p>
        <sage>
            <input>
                fsm.initial_states()
            </input>
            <output></output>
        </sage>
        <p>
            <c>FSMTransition()</c> defines a new transition between two states, as well as the input
            (the transition trigger) and output associated with the new state after the transition.
            <c>add_transition()</c> method attach the defined transition to the state machine.
            <c>transitions()</c> method is used to enumerate the list of all defined transitions of the
            state machine.</p>
        <sage>
            <input>
                from sage.combinat.finite_state_machine import FSMTransition

                # defining 3 transitions, and associating them the state machine
                drive = fsm.add_transition(FSMTransition(stop, go, 30, 'G'))
                wait = fsm.add_transition(FSMTransition(go, hold, 5, 'Y'))
                walk = fsm.add_transition(FSMTransition(hold, stop, 30, 'R'))

                fsm.transitions()
            </input>
            <output></output>
        </sage>
        <p> Once the states and transitions are defined, the state machine can be run using
            <c>process()</c> method, which then returns the intermediary outputs during the
            state machine run.</p>
        <sage>
            <input>
                # pass in the initial state and the list of inputs
                _1, _2, outputs_history = fsm.process(
                    initial_state=go,
                    input_tape=[5, 30, 30],
                )

                # print out the outputs of the state machine run
                outputs_history
            </input>
            <output></output>
        </sage>
        <p>
            <c>graph()</c> command displays the graph representation of the state machine.</p>
        <sage>
            <input>
                fsm.graph().show(
                    figsize=[6, 6],
                    vertex_size=800,
                    edge_labels=True,
                    vertex_labels=True,
                    edge_color=(.2,.4,1),
                    edge_thickness=1.0
                )
            </input>
            <output></output>
        </sage>
        <p> The <c>FiniteStateMachine</c> class also offers LATEX representation of the state
            machine using the <c>latex_options()</c> method.</p>
        <sage>
            <input>
                # define LATEX printout options
                fsm.latex_options(
                    coordinates={
                        'day': (0, 0),
                        'night': (6, 0)},
                    initial_where={'day': 'below'},
                    format_letter=fsm.format_letter_negative,
                    format_state_label=lambda x: x.label(),
                )

                # display LATEX commands
                print(latex(fsm))
            </input>
            <output></output>
        </sage>
    </subsection>
    <conclusion>
        <p>
            The above are basic commands with a typical workflow of defining and running of simple
            finite
            state machines. The general structure of the state machine can be adapted to fit
            different use
            cases. The examples shown can be customized and fine-tuned to reflect more complex
            scenarios
            (more states, different input sequences, etc.)</p>
    </conclusion>
</section>
