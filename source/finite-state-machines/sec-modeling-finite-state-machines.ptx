<?xml version="1.0" encoding="UTF-8"?>
<section xml:id="sec-modeling-finite-state-machines" xmlns:xi="http://www.w3.org/2001/XInclude"
    xml:lang="en">
    <title>State Machine in Sage</title>
    <idx>
        <h>state machines</h>
        <h>model</h>
    </idx>
    <introduction>
        <p>
            Although Sage does have a dedicated built-in rich module to handle various types of
            state machines, it may not always be sufficient to address certain use cases or implement
            specific custom behaviors of the machine. Additionally, the built-in module allows state
            machines to be defined and constructed in different ways, providing greater flexibility
            and making it more suitable from a programmer's point of view, but it may not fully
            conform to the precise definition given earlier. This highlights that it is still possible
            to model, construct, display, and run relatively simple state machines by utilizing
            general-purpose tools, such as graphs and transition matrices, to represent and operate
            on state machines.</p>
        <p>
            This section examines the process of defining states, creating a state transition graph, visualizing
            the state machine, and simulating its execution in Sage.</p>
        <aside>
            <title>Notes</title>
            <p> While Sage provides basic tools to represent and simulate state machines,
                it may not natively support more complex state machine features such as parallel
                states or hierarchical transitions.</p>
        </aside>
        </introduction>

    <subsection>
        <title>Example of Application of FSMs</title>
        <p>
            Let's consider the example of an elevator for 3 floors. Being in a given floor <m>i</m> would represent
            a distinct state <m>f_i</m>, so that we can have the subset of states <m>S=\{f_1,\;f_2,\;f_3\}</m>.</p>
        <p>
            The elevator has 3 buttons for users to select the destination floor <m>X=\{1,\;2,\;3\}</m>.
            Depending on the selected floor, the elevator can either go up, go down, or remain on the same floor.</p>
        <p>
            Let's have the set of outputs <m>O=\{N,\;U,\;D\}</m> to represent the outputs ,"do nothing", "go up",
            "go down" respectively. The following table shows the state machine representation of this elevator.</p>

        <p> Assume there is a 3-levels elevator (floors 1 thru 3). this elevator moves in the
            same direction (up or down) until it reaches the last floor while moving up, or
            the first floor while moving down. It makes stop at every floor on its way up or
            down. Each floor has 3 buttons to press while selecting the destination floor.</p>

        <p> Next, the process of modeling and simulating this system will be demonstrated using a finite
            state machine (FSM). This example includes various states <m>S=\{f_1, f_2, f_3\}</m> representing
            each of the floors, the different user inputs <m>X=\{b_1, b_2, b_3\}</m> (<em>pb</em> stands
            for push-button), and the possible outputs for the elevator <m>Z=\{U, D, N\}</m> for
            elevator going up, going down, or doing nothing. The different components of this FSM
            can be transcribed in the following table.</p>
        <p>
            <table>
                <title>Elevator State Machine: Transitions and Outputs</title>
                    <tabular halign="center">
                        <row header="yes" bottom="major">
                            <cell></cell>

                            <cell></cell>
                            <cell>next</cell>
                            <cell></cell>

                            <cell></cell>
                            <cell>output</cell>
                            <cell></cell>
                        </row>
                        <row header="yes" bottom="minor">
                            <cell>current</cell>

                            <cell><m>b_1</m></cell>
                            <cell><m>b_2</m></cell>
                            <cell><m>b_3</m></cell>

                            <cell><m>b_1</m></cell>
                            <cell><m>b_2</m></cell>
                            <cell><m>b_3</m></cell>
                        </row>

                        <row>
                            <cell><m>f_1</m></cell>

                            <cell><m>f_1</m></cell>
                            <cell><m>f_2</m></cell>
                            <cell><m>f_3</m></cell>

                            <cell><m>N</m></cell>
                            <cell><m>U</m></cell>
                            <cell><m>U</m></cell>
                        </row>

                        <row>
                            <cell><m>f_2</m></cell>

                            <cell><m>f_1</m></cell>
                            <cell><m>f_2</m></cell>
                            <cell><m>f_3</m></cell>

                            <cell><m>D</m></cell>
                            <cell><m>N</m></cell>
                            <cell><m>U</m></cell>
                        </row>

                        <row>
                            <cell><m>f_3</m></cell>

                            <cell><m>f_1</m></cell>
                            <cell><m>f_2</m></cell>
                            <cell><m>f_3</m></cell>

                            <cell><m>D</m></cell>
                            <cell><m>D</m></cell>
                            <cell><m>N</m></cell>
                        </row>
                    </tabular>
            </table>
        </p>
    </subsection>

    <subsection>
        <title>Define States, Transitions and Outputs</title>
        <p> The first step is to define the states and transitions in the state machine. We can
            represent these using lists and dictionaries.
        </p>
        <sage>
            <input>
                # Define state, input and output sets
                states = ['f1', 'f2', 'f3']
                inputs = ['b1', 'b2', 'b3']
                outputs = ['U', 'D', 'N']

                # transitions are defined as a dictionary {(current_state, input): next_state}
                transitions = {
                    ('f1', 'b1'): 'f1',
                    ('f1', 'b2'): 'f2',
                    ('f1', 'b3'): 'f3',

                    ('f2', 'b1'): 'f1',
                    ('f2', 'b2'): 'f2',
                    ('f2', 'b3'): 'f3',

                    ('f3', 'b1'): 'f1',
                    ('f3', 'b2'): 'f2',
                    ('f3', 'b3'): 'f3',
                }

                # The machine output controls how the elevator would move
                outputs = {
                    ('f1', 'b1'): 'N',
                    ('f1', 'b2'): 'U',
                    ('f1', 'b3'): 'U',

                    ('f2', 'b1'): 'D',
                    ('f2', 'b2'): 'N',
                    ('f2', 'b3'): 'U',

                    ('f3', 'b1'): 'D',
                    ('f3', 'b2'): 'D',
                    ('f3', 'b3'): 'N',
                }

                # Display the machine configuration
                print('States: ', states)
                print('Transitions: ', transitions)
                print('Outputs: ', outputs)
            </input>
            <output></output>
        </sage>
    </subsection>
    <subsection>
        <title>Graph Model of a Finite State Machine</title>
        <p>
            An FSM can be modeled as a graph where vertices represent the states, and the directed
            edge between vertices is the relationship between two states (the transition from one
            state to the other). The weight of a directed edge between two vertices represents the
            pair of input and output associated with the transition between the two states.</p>

        <p> In Sage, we can use the <c>DiGraph</c> class to represent the states, transitions and
            outputs of the state machine as a directed graph, and use the graph structure to
            visualize the state machine representation.</p>
        <sage>
            <input>
                # 'DiGraph' is imported by default. If not, it can be imported as follow
                # from sage.graphs.digraph import DiGraph

                # Initialize a directed graph
                SM = DiGraph(loops=True)

                # Add states as vertices
                SM.add_vertices(states)

                # Add transitions and outputs as edges
                for (_state, _input), next_state in transitions.items():
                    _output = outputs[(_state, _input)]
                    edge_label = f"{_input}, {_output}"
                    SM.add_edge(_state, next_state, label=edge_label)

                # Display the graph (state machine)
                SM.show(
                        figsize=[5.6, 5.6],
                        layout='circular',
                        vertex_size=250,
                        edge_labels=True,
                        vertex_labels=True,
                        edge_color=(.2,.4,1),
                        edge_thickness=1.0,
                )
            </input>
            <output></output>
        </sage>
        <p> The <c>SM.show()</c> command renders a graphical representation of the state machine.
            Each vertex in the graph represents a state, and each directed edge represents a
            transition, labeled as (input, output).</p>
    </subsection>

    <subsection>
        <title>Run the State Machine</title>
        <p>
            Next, we can simulate the state machine's behavior by creating a function that
            processes a list of inputs and transitions through the states accordingly.</p>
        <sage>
            <input>
                # Function to run the state machine
                def run_state_machine(start_state, inputs):
                    current_state = start_state
                    for _input in inputs:
                        print(f"Current state: {current_state}, Input: {_input}")

                        if (current_state, _input) in transitions:
                            current_output = outputs[(current_state, _input)]
                            current_state = transitions[(current_state, _input)]
                            print(
                                f"Transitioned to: {current_state}\n"
                                f"Output: {current_output}\n"
                            )
                        else:
                            print(
                                f"No transition/output available for input {_input} in state {current_state}"
                            )
                            break

                    print(f"Last state: {current_state}")

                # Example of running the state machine
                start_state = 'f2'
                inputs = ['b1', 'b1', 'b3', 'b2']

                run_state_machine(start_state, inputs)
            </input>
            <output></output>
        </sage>
        <p> The <c>run_state_machine</c> function simulates the state machine by processing a list
            of inputs starting from an initial state.</p>
    </subsection>

    <subsection>
        <title>Using Sage built-in `FiniteStateMachine'</title>
        <p>
            In this section, the Sage built-in library for FSM is used to model and run a very basic traffic
            light system, controlled only by a preset timer. The system moves between 3 different states
            describing the flow of road traffic: <em>Free-flowing (F)</em>, <em>Slowing-down (S)</em>, and
            <em>Halted (H)</em>, which respectively correspond to the 3 traffic lights: green (G), yellow (Y),
            and red (R). These would be the outputs of the system.
        </p>
        <p>
            The timer fires an event upon expiration of a preset duration, and that event triggers the state
            transition. The timer has 2 different settings: a 30-second wait time that precedes the switch of
            the traffic light from red to green, and also from green to yellow, and a 5-second wait time before
            the switch of the traffic light from yellow to red.
        </p>
        <p>
            The command <c>FiniteStateMachine()</c> constructs an <em>empty</em> state machine (no states, no transitions).</p>
        <sage>
            <input>
                from sage.combinat.finite_state_machine import FSMState

                # FSM states, inputs and outputs
                states = ['F', 'S', 'H']    # Free-flowing, Slowing-down, Halted
                inputs = [30, 5, 30]        # timer durations before state transitions
                outputs = ['G', 'Y', 'R']   # traffic light: Green, Yellow, Red

                # Create an empty state machine object
                fsm = FiniteStateMachine()
                fsm
            </input>
            <output></output>
        </sage>
        <p>
            The function <c>FSMState()</c> defines a state for a given label. The <c>is_initial</c> flag can
            be set to true to set the current state as the <em>initial state</em> of the finite state machine.
            The method <c>add_state()</c> appends the created state to an existing state machine.</p>
        <sage>
            <input>
                # Define a new state then adding it
                free_flowing = FSMState('F', is_initial=True)
                fsm.add_state(free_flowing)

                # Adding more states by their labels (saving state handlers, to use them in state transitions)
                slowing_down = fsm.add_state('S')
                halted = fsm.add_state('H')

                # the FiniteStateMachine instance
                fsm
            </input>
            <output></output>
        </sage>
        <p> To check whether or not a finite state machine has a state defined, <c>has_state()</c>
            method can be used by passing in the state label (case-sensitive).</p>
        <sage>
            <input>
                fsm.has_state('F')
            </input>
            <output></output>
        </sage>
        <p>
            The function <c>states()</c> enumerates the list of all defined states of the state machine.</p>
        <sage>
            <input>
                fsm.states()
            </input>
            <output></output>
        </sage>
        <p>
            The method <c>initial_states()</c> lists the defined initial state(s) of the state machine.</p>
        <sage>
            <input>
                fsm.initial_states()
            </input>
            <output></output>
        </sage>
        <p>
            To define a new transition between two states (as well as the input triggering the transition, and
            the output associated with the state transition), the method <c>FSMTransition()</c> can be used. The
            method <c>add_transition()</c> attaches the defined transition to the state machine, and the function
            <c>transitions()</c> enumerates the list of all defined transitions of the state machine.</p>
        <sage>
            <input>
                from sage.combinat.finite_state_machine import FSMTransition

                # defining 3 transitions, and associating them the state machine
                # After 30sec, transition from free-flowing to slowing-down, and set traffic light to yellow
                fsm.add_transition(FSMTransition(free_flowing, slowing_down, 30, 'Y'))

                # After 5sec, transition from slowing-down to halted, and set traffic light to red
                fsm.add_transition(FSMTransition(slowing_down, halted, 5, 'R'))

                # After 30sec, transition from halted back to free-flowing, and set traffic light to green
                fsm.add_transition(FSMTransition(halted, free_flowing, 30, 'G'))

                fsm.transitions()
            </input>
            <output></output>
        </sage>
        <p> Once the states and transitions are defined, the state machine can be run using
            <c>process()</c> method, which then returns the intermediary outputs during the
            state machine run.</p>
        <sage>
            <input>
                # pass in the initial state and the list of inputs
                *_, outputs_history = fsm.process(
                    initial_state=free_flowing,
                    input_tape=[30, 5, 30],
                )

                # print out the outputs of the state machine run
                outputs_history
            </input>
            <output></output>
        </sage>
        <p>
            <c>graph()</c> command displays the graph representation of the state machine.</p>
        <sage>
            <input>
                fsm.graph().show(
                    figsize=[6, 6],
                    vertex_size=800,
                    edge_labels=True,
                    vertex_labels=True,
                    edge_color=(.2,.4,1),
                    edge_thickness=1.0
                )
            </input>
            <output></output>
        </sage>
        <p> The <c>FiniteStateMachine</c> class also offers <latex /> representation of the state
            machine using the <c>latex_options()</c> method.</p>
        <sage>
            <input>
                # define printout options
                fsm.latex_options(
                    format_state_label=lambda x: x.label(),
                )

                # display commands
                print(latex(fsm))
            </input>
        </sage>
        <p>
            The <latex /> printout may not have all elements displayed (the labels on the edges),
            but it is a start and it can still be customized further. The following figure shows a
            rendering of the above <latex /> commands.</p>
        <figure>
            <media>
                <image source="finite-state-machines/first_traffic_light_FSM.png" width="67%"/>
            </media>
            <caption>FSM graph output.</caption>
        </figure>
        <p> All available options for the <c>latex_options()</c> method can be listed using
            the <c>help()</c> function.</p>
        <sage>
            <input>
                help(FiniteStateMachine.latex_options)
            </input>
        </sage>
</subsection>
    <conclusion>
        <p>
            The above are basic commands with a typical workflow of defining and running of simple finite state machines. The general structure of the state machine can be adapted to fit different use cases. The examples shown can be customized and fine-tuned to reflect more complex scenarios (more states, different input sequences, etc.)</p>
    </conclusion>
</section>
