<section xml:id="sec-tables-of-operations">
    <title>Tables of Operations</title>
    <introduction>
        <p>
            This section delves into the representation of meet <m>(⊓)</m> and join <m>(⊔)</m> operations within lattices using operation tables. Such tables are pivotal for visualizing the algebraic structure of lattices and understanding how elements combine under each operation.
        </p>
    </introduction>

    <subsection xml:id="meet-operation-table">
        <title>Meet Operation Table</title>
        <p>
            The meet operation table illustrates the greatest lower bound, or meet, for every pair of elements in the lattice. 
        </p>
        <p>
            The function to output the table is not available in sage, but we can define our own function to output the table as a matrix. 
        </p>
        <sage>
            <input>
                # Define the poset
                L = Poset((['a', 'b', 'c', 'd', 'e', 'f', 'g'], 
                [('a', 'b'), ('a', 'c'), ('b', 'd'), ('c', 'd'), 
                 ('c', 'e'), ('d', 'f'), ('e', 'f'), ('f', 'g')]), 
                 cover_relations=True)

                # Get the list of elements in the poset
                elements = L.list()

                # Initialize matrices for meet table
                meet_matrix = matrix(QQ, len(elements), len(elements))


                # Populate the matrix
                for i, x in enumerate(elements):
                    for j, y in enumerate(elements):
                        meet_matrix[i, j] = elements.index(L.meet(x, y))

                # Display the tables
                print("Meet Table:")
                show(meet_matrix)
            </input>
            <output>
                # Displays the meet operation table as a matrix.
            </output>
        </sage>
    </subsection>

    <subsection xml:id="join-operation-table">
        <title>Join Operation Table</title>
        <p>
            Conversely, the join operation table presents the least upper bound, or join, for each pair of lattice elements. 
        </p>
        <p>
            Similarly, we can define a function to output the join table as a matrix as well. 
        </p>
        <sage>
            <input>
                # Define the poset
                L = Poset((['a', 'b', 'c', 'd', 'e', 'f', 'g'], 
                [('a', 'b'), ('a', 'c'), ('b', 'd'), ('c', 'd'), 
                 ('c', 'e'), ('d', 'f'), ('e', 'f'), ('f', 'g')]), 
                 cover_relations=True)

                # Get the list of elements in the poset
                elements = L.list()

                # Initialize matrices for join table
                join_matrix = matrix(QQ, len(elements), len(elements))


                # Populate the matrix
                for i, x in enumerate(elements):
                    for j, y in enumerate(elements):
                        join_matrix[i, j] = elements.index(L.join(x, y))

                # Display the tables
                print("Join Table:")
                show(join_matrix)
            </input>
            <output>
                # Outputs the join operation table in matrix form.
            </output>
        </sage>
    </subsection>


</section>
