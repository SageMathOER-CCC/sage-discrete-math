<section xml:id="sec-basics" xmlns:xi="http://www.w3.org/2001/XInclude">
  <title>Basics</title>

  <subsection>
    <title>Graph Definition</title>
    <p>In discrete mathematics, a graph is a fundamental concept used to model pairwise relations between objects. A graph is defined as an ordered pair <m>G = (V, E)</m>, where:</p>
    <ul>
        <li>
            <p><m>V</m> is a set of vertices (also called nodes or points).</p>
        </li>
        <li>
            <p><m>E</m> is a set of edges (also called links or lines), which are unordered pairs of vertices (in an undirected graph) or ordered pairs of vertices (in a directed graph).</p>
        </li>
    </ul>    
    <p>The vertices represent the objects, and the edges represent the connections or relationships between these objects.</p>
    

    <p>
        The first method involves specifying the edges directly, where each edge is defined by a pair of vertices:
    </p>
    <sage>
        <input>
            G = Graph([('A', 'B'), ('B', 'C'), ('C', 'D'), ('D', 'E'), ('E', 'A'), ('A', 'C'), ('B', 'E')])
            G.show()
        </input>
        <output>
            # A graphical representation of the graph with vertices A, B, C, D, E forming a pentagon and additional diagonals A-C and B-E.
        </output>
    </sage>
    <p>
        The second method uses a list of vertices and a list of edges, providing a clear separation between the graph's vertices and edges:
    </p>
    <sage>
        <input>
            V = ['A', 'B', 'C', 'D', 'E']
            E = [('A', 'B'), ('B', 'C'), ('C', 'D'), ('D', 'E'), ('E', 'A'), ('A', 'D'), ('C', 'E')]
            G = Graph([V, E])
            G.plot()
        </input>
        <output>
            # A graphical representation of the graph with vertices A, B, C, D, E forming a pentagon and additional diagonals A-D and C-E.
        </output>
    </sage>
    <p>
        Both methods allow for the creation and visualization of graphs in Sage, with the choice of method depending on the format of the data available and personal preference for clarity and organization.
    </p>
    <p>
        Graphs can also be defined by specifying the connections from each vertex. In Sage, an undirected graph can be created using a dictionary to represent the adjacency list of each vertex, indicating the vertices that are connected by an edge.
    </p>
    <sage>
        <input>
            G = Graph({1: [2, 3, 4], 2: [1, 3, 4], 3: [1, 2, 4], 4: [1, 2, 3]})
            G.plot()
        </input>
        <output>
            # A graphical representation of the undirected graph. All vertices (1, 2, 3, and 4) are interconnected.
        </output>
    </sage>

      <p>
          Sage offers a wide array of predefined graphs for experimentation and study. These graphs represent important concepts and structures in graph theory.
      </p>
      <p>
          Examples of creating and visualizing some well-known predefined graphs:
      </p>
      <sage>
          <input>
              P = graphs.PetersenGraph()
              P.show()
              K = graphs.CompleteGraph(5)
              K.show()
              T = graphs.TetrahedralGraph()
              T.show()
              D = graphs.DodecahedralGraph()
              D.show()
              H = graphs.HexahedralGraph()
              H.show()
          </input>
          <output>
              # Graphical representations of the Petersen graph, complete graph on 5 vertices, tetrahedral, dodecahedral, and hexahedral graphs.
          </output>
      </sage>
      <p>
          These examples include the Petersen graph, a complete graph on 5 vertices (also known as the K5 graph), the tetrahedral graph, the dodecahedral graph, and the hexahedral (or cubic) graph, showcasing a variety of graph structures.
      </p>
      <p>
          Defining a graph with data structures before creation allows for managing complex graphs efficiently. This approach is suitable for graphs with a large number of vertices or intricate connectivity.
      </p>
      <p>
          An example using a dictionary to define a graph:
      </p>
      <sage>
          <input>
              graph_data = {'A': ['B', 'C', 'E'], 'B': ['A', 'C', 'D'], 'C': ['A', 'B', 'D', 'E'], 'D': ['B', 'C', 'E'], 'E': ['A', 'C', 'D']}
              G = Graph(graph_data)
              G.show()
          </input>
          <output>
              # A graphical representation of the graph defined by the dictionary, showing a complex network of connections among five vertices.
          </output>
      </sage>
      <p>
          This method provides a clear and organized way to define the relationships between vertices, especially for complex or large-scale graphs.
      </p>
</subsection>

  <subsection>
    <title>Weighted Graphs</title>
    <p>
        Weighted graphs extend the concept of graphs by associating a weight, typically a numerical value, with each edge. These weights can represent distances, costs, capacities, or other quantities relevant to the problem being modeled. In Sage, weighted graphs are easily handled, allowing for the exploration of algorithms and properties specific to these types of graphs.
    </p>
    <p>
        To create a weighted graph, you can add a third element to each pair of vertices representing the weight.
    </p>
    <p>
        Here is an example of defining a weighted graph with five vertices, forming a pentagon where each edge has a unique weight:
    </p>
    <sage>
        <input>
            V = ['A', 'B', 'C', 'D', 'E']
            E = [('A', 'B', 2), ('B', 'C', 3), ('C', 'D', 4), ('D', 'E', 5), ('E', 'A', 1)]
            G = Graph([V, E], weighted=True)
            G.plot(edge_labels=True)
        </input>
        <output>
            # A graphical representation of the weighted graph, showing vertices A, B, C, D, E and edges with weights.
        </output>
    </sage>
    <p>
        In the code above, the graph <c>G</c> is defined with vertices and edges, where each edge is a tuple containing two vertices and the weight of the edge. The <c>weighted=True</c> parameter indicates that the graph is weighted, and the <c>plot(edge_labels=True)</c> method visualizes the graph with edge weights displayed.
    </p>
</subsection>

<subsection>
    <title>Graph Characteristics</title>
    <p>
        Understanding the characteristics of graphs is fundamental to analyzing their properties and behaviors. These characteristics provide essential insights into the structure of the graph. Sage offers various functions to compute and analyze these characteristics, which are crucial for graph theory studies.
    </p>
    <p>
        To list all vertices of a graph, we use the <c>G.vertices()</c> method, which returns a list of the graph's vertices.
    </p>
    <sage>
        <input>
            G.vertices()
        </input>
        <output>
            # List of vertices in the graph.
        </output>
    </sage>
    <p>
        To list all edges of a graph, the <c>G.edges()</c> method is used. This returns a list of tuples representing the graph's edges.
    </p>
    <sage>
        <input>
            G.edges()
        </input>
        <output>
            # List of edges in the graph.
        </output>
    </sage>
    <p>
        The order of a graph <m>G=(V,E)</m> is the number of vertices <m>|V|</m>. It provides a measure of its size.
    </p>
    <p>
        To find the order of the graph:
    </p>
    <sage>
        <input>
            G = Graph([('A', 'B'), ('B', 'C'), ('C', 'D'), ('D', 'E'), ('E', 'A'), ('A', 'C'), ('B', 'D')])
            G.order()
        </input>
        <output>
            # The number of vertices in the graph G.
        </output>
    </sage>
    <p>
        The size of a graph <m>G=(V,E)</m> is the number of edges <m>|E|</m>. It is indicative of the graph's complexity.
    </p>
    <p>
        To find the size of the graph:
    </p>
    <sage>
        <input>
            G = Graph([('A', 'B'), ('B', 'C'), ('C', 'D'), ('D', 'E'), ('E', 'A'), ('A', 'C'), ('B', 'D')])
            # Using the same graph G from the previous example
            G.size()
        </input>
        <output>
            # The number of edges in the graph G.
        </output>
    </sage>
    <p>
        The degree of a vertex in <m>G</m> is the number of edges incident to the vertex. This is important for understanding the connectivity within the graph.
    </p>
    <p>
        To find the degree of vertex <m>A</m>:
    </p>
    <sage>
        <input>
            G = Graph([('A', 'B'), ('B', 'C'), ('C', 'D'), ('D', 'E'), ('E', 'A'), ('A', 'C'), ('B', 'D')])
            # above from previous code  
            G.degree('A')
        </input>
        <output>
            # The degree of vertex 'A' in the graph.
        </output>
    </sage>
    <p>
        By calling <c>G.degree('A')</c>, Sage returns the degree of vertex 'A', which is the count of how many edges are incident to 'A'.
    </p>
    <p>
        To find the degree of all vertices:
    </p>
    <sage>
        <input>
            G = Graph([('A', 'B'), ('B', 'C'), ('C', 'D'), ('D', 'E'), ('E', 'A'), ('A', 'C'), ('B', 'D')])
            # Using the same graph G from the previous examples
            G.degree_sequence()
        </input>
        <output>
            # The degree sequence of the graph, listing the degrees of all vertices.
        </output>
    </sage>
  <p>
      The method <c>G.degree_sequence()</c> provides a list of degrees of all vertices in the graph, which can be used to analyze the graph's degree distribution.
  </p>
  <p>
    The <m>degree</m> of a specific vertex within a graph indicates how many connections (edges) that vertex has to others. This is useful for identifying how connected or central a vertex is within the graph.
</p>

</subsection>

<subsection>
  <title>Graphs and Matrices</title>
  <p>
      The <em>adjacency matrix</em> of a graph is a square matrix used to represent which vertices (or nodes) of the graph are adjacent to which other vertices. Each entry <m>a_{ij}</m> in the matrix is equal to 1 if there is an edge from vertex <c>i</c> to vertex <c>j</c>, and a 0 otherwise.
  </p>
  <p>
      To create a graph from an adjacency matrix:
  </p>
  <sage>
      <input>
          A = Matrix([[0, 1, 0, 0, 1], [1, 0, 1, 0, 0], [0, 1, 0, 1, 0], [0, 0, 1, 0, 1], [1, 0, 0, 1, 0]])
          G = Graph(A)
          G.plot()
      </input>
      <output>
          # A graphical representation of the graph defined by the adjacency matrix.
      </output>
  </sage>
  <p>
      In this example, the matrix <c>A</c> represents the adjacency matrix of a graph, and <c>Graph(A)</c> creates the graph based on that matrix. The plot shows the resulting graph.
  </p>
  <p>
      The <em>incidence matrix</em> is another matrix representation of a graph, which describes the relationship between vertices and edges. In this matrix, rows correspond to vertices, and columns correspond to edges, with entries indicating whether a vertex is incident to an edge.
  </p>
  <p>
      Besides creating graphs from matrices, you can also obtain these matrix representations from a given graph in Sage.
  </p>
  <p>
      To get the adjacency matrix of a graph:
  </p>
  <sage>
      <input>
          A = Matrix([[0, 1, 0, 0, 1], [1, 0, 1, 0, 0], [0, 1, 0, 1, 0], [0, 0, 1, 0, 1], [1, 0, 0, 1, 0]])
          G = Graph(A)
          # above from previous code  
          G.adjacency_matrix()
      </input>
      <output>
          # The adjacency matrix of the graph G.
      </output>
  </sage>
  <p>
      And to get the incidence matrix:
  </p>
  <sage>
      <input>
          A = Matrix([[0, 1, 0, 0, 1], [1, 0, 1, 0, 0], [0, 1, 0, 1, 0], [0, 0, 1, 0, 1], [1, 0, 0, 1, 0]])
          G = Graph(A)
          # above from previous code 
          G.incidence_matrix()
      </input>
      <output>
          # The incidence matrix of the graph G.
      </output>
  </sage>
</subsection>

<subsection>
    <title>Manipulating Graphs in Sage</title>
    <p>
        Modifying graphs by adding or removing vertices and edges allows us to observe how these changes affect graph properties. Sage provides user-friendly functions for these modifications, facilitating dynamic exploration of graphs.
    </p>
    <p>
        To add a vertex to a graph:
    </p>
    <sage>
        <input>
            G = Graph([(1, 2), (2, 3), (3, 4), (4, 1)])
            G.add_vertex(5)
            G.plot()
        </input>
        <output>
            # A graphical representation of the graph with an additional vertex.
        </output>
    </sage>
    <p>
        To remove a vertex from a graph:
    </p>
    <sage>
        <input>
            G = Graph([(1, 2), (2, 3), (3, 4), (4, 1)])
            G.add_vertex(5)
            # Using the graph G from the previous code
            G.delete_vertex(5)
            G.plot()
        </input>
        <output>
            # The graph with vertex 5 removed.
        </output>
    </sage>
    <p>
        To add an edge between two vertices in a graph:
    </p>
    <sage>
        <input>
            G = Graph([(1, 2), (2, 3), (3, 4), (4, 1)])
            # Using the graph G from the initial state
            G.add_edge(1, 3)
            G.plot()
        </input>
        <output>
            # The graph with a new edge between vertices 1 and 3.
        </output>
    </sage>
    <p>
        To delete an edge from a graph:
    </p>
    <sage>
        <input>
            G = Graph([(1, 2), (2, 3), (3, 4), (4, 1)])
            G.add_edge(1, 3)
            # Using the graph G from the previous code
            G.delete_edge(1, 3)
            G.plot()
        </input>
        <output>
            # The graph with the edge between vertices 1 and 3 removed.
        </output>
    </sage>
    <p>
        These methods for adding and deleting vertices and edges provide a robust framework for studying the impact of structural changes on graph dynamics within Sage.
    </p>
  </subsection>
  



</section>
